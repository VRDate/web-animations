<!DOCTYPE html>
<!-- vim: set expandtab ts=2 sw=2 tw=80: -->
<html>
  <head>
    <title>Web Animations 1.0</title>
    <meta http-equiv='Content-Type' content='text/html;charset=utf-8'/>
    <script src='http://dev.w3.org/2009/dap/ReSpec.js/js/respec.js'
      class='remove'></script>
    <script
      src='http://dev.w3.org/2009/dap/ReSpec.js/js/lang/sh_javascript.min.js'
      class='remove'></script>
    <script class='remove'>
      var respecConfig = {
        // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use
        // ED.
        specStatus: "unofficial",

        // the specification's short name, as in
        // http://www.w3.org/TR/short-name/
        // shortName:            "web-anim",

        // if your specification has a subtitle that goes below the main
        // formal title, define it here
        // subtitle   :  "an excellent document",

        // if you wish the publication date to be other than today, set this
        // publishDate:  "2009-08-06",

        // if the specification's copyright date is a range of years, specify
        // the start date here:
        // copyrightStart: "2005"

        // if there is a previously published draft, uncomment this and set
        // its YYYY-MM-DD date and its maturity status
        // previousPublishDate: "1977-03-15",
        // previousMaturity: "WD",

        // if there a publicly available Editor's Draft, this is the link
        // edDraftURI:
        // "http://dev.w3.org/2009/dap/ReSpec.js/documentation.html",

        // if this is a LCWD, uncomment and set the end of its review period
        // lcEnd: "2009-08-05",

        // if you want to have extra CSS, append them to this list
        // it is recommended that the respec.css stylesheet be kept
        extraCSS: ["http://dev.w3.org/2009/dap/ReSpec.js/css/respec.css",
                   "web-animations.css"],

        // Turning off inlineCSS for now since if extraCSS points to
        // a relative URL your testing from a file URL the XHR will fail.
        // Probably should turn this back on once this is hosted on a server
        // somewhere.
        inlineCSS: false,

        // editors, add as many as you like
        // only "name" is required
        editors:  [
            { name: "Brian Birtles", mailto: "bbirtles@mozilla.com",
              company: "Mozilla Japan", companyURL: "http://mozilla.jp/" },
            { name: "Shane Stephens", mailto: "shans@google.com",
              company: "Google, Inc", companyURL: "http://www.google.com/" },
            { name: "Rik Cabanier", mailto: "cabanier@adobe.com",
              company: "Adobe Systems", companyURL: "http://www.adobe.com/" },
            { name: "Alex Danilo", mailto: "adanilo@google.com",
              company: "Google, Inc", companyURL: "http://www.google.com/" },
        ],

        // authors, add as many as you like.
        // This is optional, uncomment if you have authors as well as editors.
        // only "name" is required. Same format as editors.

        //authors:  [
        //    { name: "Your Name", url: "http://example.org/",
        //      company: "Your Company", companyURL: "http://example.com/" },
        //],

        // XXX If we continue using ReSpec then we need to tweak it to support
        // multiple working groups. It includes updating the patent section
        // prose to say "groups" instead of "group" etc.
        // name of the WG
        // wg: "CSS Working Group (part of the Style Activity) and the SVG " +
        //     "Working Group (part of the Graphics Activity)",

        // URI of the public WG page
        // wgURI: "http://www.w3.org/Graphics/fx/",

        // name (without the @w3c.org) of the public mailing to which comments
        // are due
        wgPublicList: "public-fx",

        // URI of the patent status for this WG, for Rec-track documents
        // !!!! IMPORTANT !!!!
        // This is important for Rec-track documents, do not copy a patent URI
        // from a random document unless you know what you're doing. If in
        // doubt ask your friendly neighbourhood Team Contact.
        wgPatentURI:  "",

        noIDLSorting: true,
        noIDLIn: true
      };
    </script>
    <!--
      ReSpec.js wishlist:

      Add here any issues you find with ReSpec including missing features. It
      will help us decide if we should continue using it and work out what we
      need to fix.

      * Need ability to cross-reference members of interfaces (e.g. constants
        etc.)
      * Get rid of the description section next to parameters? It seems more
        natural to describe the parameters in the description of the method?
      * Allow making cross-references to specific methods and members.
      * Don't make unofficial drafts use the Creative Commons Attribution
        license.
    -->
  </head>
  <body>
    <section id='abstract'>
      This is the abstract for your specification.
    </section>

    <section>
      <h2>Introduction</h2>
      <p class="todo">
        Shane, onegaishimasu!
      </p>
      <section>
        <h3>Relationship to other specifications</h3>
        <p class="todo">
          CSS Transitions, CSS Animations, SVG, SMIL<br/>
          Thanks Shane &#x263A;
        </p>
      </section>
    </section>

    <section class="informative">
      <h2>The animation timeline</h2>
      <p>
        Each document contains a timeline to which animations may be added.
        Each animation has an interval during which it is scheduled to animate.
      </p>
      <div class="figure">
        <object data="img/timeline.svg" width="600"></object>
      </div>
      <p class="caption">
        At time <em>t</em> animations A and B are animating.
        Animation C has finished animating and is now inactive.
        Animation D has yet to begin and is also inactive.
      </p>
      <section>
        <h3>Start of the timeline</h3>
        <p class="todo">
          Define when the timeline starts&mdash;is it document load, or can it
          start beforehand?
        </p>
      </section>
    </section>

    <section>
      <h2>Animations in the timeline</h2>
      <p>
        Animations in the timeline are represented by
        <code>WebAnimationInstance</code> objects.
      </p>
      <section>
        <h3>The <code>WebAnimationInstance</code> interface</h3>
        <dl title="interface WebAnimationInstance : WebTimedItem" class="idl">
          <dt>attribute WebAnimationFunction function</dt>
          <dd>
            The animation function to apply.
          </dd>
          <dt>readonly attribute WebAnimation? animation</dt>
          <dd>
            For live animation instances (see <a href="#creating-animations"
            class="sectionRef"></a>), the <code>WebAnimation</code> object from
            which this object was minted. For independent animation instances,
            this property is <code>null</code>.
          </dd>
          <dt>readonly attribute Element targetElement</dt>
          <dd>
            The element being animated by this object.
          </dd>
          <dt>bool makeNotLive()</dt>
          <dd>
            <p>
              Makes this object independent of the template from which it was
              created.
              See <a href="#creating-animations" class="sectionRef"></a>.
            </p>
            <p>
              After this method returns, the <code>animation</code>
              property will be <code>null</code>.
            </p>
            <p>
              Returns <code>true</code> if this object was previously a live
              animation instance, <code>false</code> if this object was already
              an independent animation instance.
            </p>
          </dd>
        </dl>
        <div class="feedbackWanted">
          We've used <code>Web*</code> as a prefix on all interfaces in this
          specification. Is this required? Are we likely to get clashes with
          existing content if we define, for example, <code>Animation</code>? Is
          <code>Web*</code> a suitable prefix? An alternative might be
          <code>FX*</code> but <code>FXAnimation</code> sounds tacky and very
          80s.
        </div>
      </section>
    </section>

    <section>
      <h2>Creating animations</h2>
      <p>
        <code>WebAnimationInstance</code> objects are not created directly, but
        via a separate <code>WebAnimation</code> object. The
        <code>WebAnimation</code> object acts a template allowing the same set
        of animation parameters to be used multiple times with multiple target
        elements.
      </p>
      <p>
        A <code>WebAnimationInstance</code> can be in one of two states with
        regards to the relationship between it and the <code>WebAnimation</code>
        that produced it.
      </p>
      <dl>
        <dt>Live animation instance</dt>
        <dd>
          Changes made to the <code>WebAnimation</code> object are reflected in
          the <code>WebAnimationInstance</code> object.
        </dd>
        <dt>Independent animation instance</dt>
        <dd>
          Changes made to the <code>WebAnimation</code> object have no effect on
          the <code>WebAnimationInstance</code> object.
        </dd>
      </dl>
      <p class="todo">
        Add a non-normative diagram which shows a live animation instance and an
        independent one.
      </p>
      <p>
        Live animation instances can be converted to independent animation
        instances by one of two means:
      </p>
      <ol>
        <li>
          Calling the <code>makeNotLive</code> method of the
          <code>WebAnimationInstance</code> object.
        </li>
        <li>
          Modifying any of the members of the <code>function</code> or
          <code>timing</code> properties of the
          <code>WebAnimationInstance</code> object. This includes redundant
          modifications, that is, setting a property to its current value.
          <!--
           The redundant modification condition is an attempt to eliminate an
           area where interop might fail subtley.

           If, internally, implementation A filters out redundant changes whilst
           implementation B blindly accepts all changes we still want the same
           behaviour with regards to becoming independent. It's easier, more
           convenient and, I think, more intuitive for authors to define it this
           way.

           The alternative, requiring redundant changes to be ignored, is more
           complex as we need to specify what consitutes a redundant change and
           that's not always easy as the data types become complex. For example,
           what constitutues a redundant change to an SVGLength is not always
           obvious.
           -->
        </li>
      </ol>
      <p>
        Once independent, animation instances cannot be made live again.
      </p>
      <p class="note">
        One implication of the fact that a live instance can be converted to an
        independent instance is that when a live instance is created, the object
        identity of its <code>function</code> and <code>timing</code> properties
        must differ from those of the animation from which it was created. This
        is because, for example, modifying the <code>timing.duration</code>
        property of a live animation instance and hence converting it to an
        independent animation instance, cannot at the same time change the
        object identity of the <code>timing</code> property.
      </p>
      <pre class="example sh_javascript">
        // Create a new animation
        var anim = new WebAnimation();
        anim.timing.duration = 1;

        // Create a live instance
        var instance = a.animateLive(document.getElementById('a'));
        alert(instance.timing.duration); // Displays "1"

        // Modify the animation
        anim.timing.duration = 2;
        alert(instance.timing.duration); // Displays "2"

        // Modify both the animation and instance
        instance.timing.duration = 3;    // instance is now independent
        anim.timing.duration = 4;
        alert(instance.timing.duration); // Displays "3"
      </pre>
      <section>
        <h3>The <code>WebAnimation</code> interface</h3>
        <p>
          <dl title="[Constructor] interface WebAnimation" class="idl">
            <dt>attribute WebTiming timing</dt>
            <dd>
              The timing parameters to use for generated animations.
            </dd>
            <dt>attribute WebAnimationFunction function</dt>
            <dd>
              The animation function to apply.
            </dd>
            <dt>sequence&lt;WebAnimationInstance&gt; animate ()</dt>
            <dd>
              <p>
                Creates a series of independent
                <code>WebAnimationInstance</code> objects, one for each element
                in <code>target</code>. For each <code>element</code> in
                <code>target</code> the associated animation is appended to the
                animation group corresponding to
                <code>element.ownerDocument.animationRoot</code>.
              </p>
              <dl class="parameters">
                <dt>any target</dt>
                <dd>
                  The element(s) to be animated.
                  May be one of the following types:
                  <code>Element</code>, <code>NodeList</code>,
                  <code>Element[]</code>.
                  If <code>target</code> is of type
                  <code>NodeList</code> all nodes in the list that are not of
                  type <code>ELEMENT_NODE</code> are ignored.
                </dd>
                <dt>optional float startTime</dt>
                <dd>
                  The start time for the animation instance in the time space of
                  the <code>WebAnimationGroupInstance</code> to which it is
                  appended.
                  If this parameter is not specified it will default to the
                  current time of the <code>WebAnimationGroupInstance</code> to
                  which it is appended.
                </dd>
              </dl>
            </dd>
            <dt>sequence&lt;WebAnimationInstance&gt; animateWithParent ()</dt>
            <dd>
              <p>
                Similar to <code>animate</code>, this method creates one
                independent <code>WebAnimationInstance</code> object for each
                element in <code>target</code>, but then appends the resulting
                <code>WebAnimationInstance</code> objects as children of the
                given <code>parentGroup</code>, if provided.
                If <code>parentGroup</code> is <code>null</code>, the
                <code>WebAnimationInstance</code> objects will not be added to
                any group.
              </p>
              <dl class="parameters">
                <dt>any target</dt>
                <dd>
                  As with <code>animate</code>.
                </dd>
                <dt>WebAnimationGroupInstance? parentGroup</dt>
                <dd>
                  The animation group instance to which animation instances
                  should be appended.
                </dd>
                <dt>optional float startTime</dt>
                <dd>
                  <p>
                    Represents a time in the context of the
                    <code>WebAnimationGroupInstance</code> to which the
                    generated <code>WebAnimationInstance</code> objects will be
                    appended.
                  </p>
                  <p>
                    If this parameter is not specified it will default to the
                    current time of <code>parentGroup</code> if it is not
                    <code>null</code>, otherwise it will default to zero.
                  </p>
                </dd>
              </dl>
            </dd>
            <dt>sequence&lt;WebAnimationInstance&gt; animateLive (any target,
              optional float startTime)</dt>
            <dd>
              As with <code>animate</code> with the exception that the animation
              instances generated by this method are live.
            </dd>
            <dt>sequence&lt;WebAnimationInstance&gt; animateLiveWithParent
              (any target, WebAnimationGroupInstance? parentGroup,
               optional float startTime)</dt>
            <dd>
              As with <code>animateWithParent</code> with the exception that the
              animation instances generated by this method are live.
            </dd>
          </dl>
          <div class="feedbackWanted">
            <p>
              The requirements for the <code>animate</code> are as follows.
              Regarding the animation target(s) we want to support:
            </p>
            <pre>
              animation.animate(document.getElementById("a"));
              animation.animate(document.querySelectorAll("div.warning"));</pre>
            <p>
              That is we want to support at least:
            </p>
            <ul>
              <li>Element</li>
              <li>NodeList (for <code>querySelectorAll</code>,
              <code>getElementsByTagName</code>, <code>Node.childNodes</code>
              etc.)</li>
            </ul>
            <p>
              It would be nice to also support an array of Elements.
            </p>
            <p>
              We also need to be able to specify the start time.
              However, it is probably very useful to have a default behavior
              that uses the current time of the container.
              That is, ideally this parameter should be optional.
            </p>
            <p>
              Regarding the parent animation group, there are three possible
              scenarios we probably want to support:
            </p>
            <ul>
              <li>Specify an explicit parent group</li>
              <li>Use the default animation group (<code>animationRoot</code>)
              of the element's <code>ownerDocument</code></li>
              <li>Have no parent group (This is particularly important
              animations destined for sequential animation groups containers
              where the order of children is important and so you might want to
              insert the animation yourself at a particular position. It's also
              likely there will be situations where you want to make the
              animation and attach it later such as a helper function that
              returns an animation instance object for the caller to
              insert.)</li>
            </ul>
            <p>
              Finally, we want to be able to trigger both live and independent
              animations.
            </p>
            <p>
              That gives you up to 36 permutations of ways of calling
              <code>animate</code> (and cousins). At the same time, we want
              <code>animate</code> to be as simple to use as possible. The above
              interface is an attempt to balance these requirements. It depends
              on WebIDL and ECMAScript either being able to do overloading by
              parameter type or accepting an "any" type and then checking the
              type of the argument. I'm not sure what the best way is to do
              this.
            </p>
          </div>
        </p>
      </section>
    </section>

    <section>
      <h2>Timing animations</h2>
      <section class="informative">
        <h3>Animation states</h3>
        <p>
          An individual animation instance can be in one of three possible
          states:
        </p>
        <dl>
          <dt>Animating (active)</dt>
          <dd>
            The animation instance is executing, and will apply its effect to
            its target.
          </dd>
          <dt>Filling (active)</dt>
          <dd>
            The animation instance has yet to start executing or has already
            finished but is still effecting its target due to the fill mode
            specified (see <a href="#animation-fill-behavior"
              class="sectionRef"></a>).
          </dd>
          <dt>Inactive</dt>
          <dd>
            The animation instance has yet to start executing or has already
            finished and is not effecting its target. Animations that do not
            belong to a group and consequently have no notion of time are also
            considered inactive (see <a href="#grouping-and-synchronization"
            class="sectionRef"></a>).
          </dd>
        </dl>
        <p>
          An animation instance is considered <em>active</em> if it is in either
          the <em>animating</em> or <em>filling</em> state.
        </p>
        <div class="todo">
          <p>
            Basically, the fill mode affects the state and the return value of
            <code>iterationTime</code>.
          </p>
          <p>
            Add a diagram showing these states.
          </p>
          <p>
            Revise the algorithms to that the <var>iteration time</var>
            incorporates the fill mode.
          </p>
        </div>
        <section>
          <h3>The animation interval</h3>
          <p>
            The period that an animation instance is animating is called the
            <em>animation interval</em>.
            Each animation instance has only one such interval.
          </p>
          <p>
            The start of the interval is determined by the <var>start
            time</var> of the animation instance but may be shifted by
            a <var>start delay</var> on the animation instance.
          </p>
          <p>
            The end of the interval is determined by the <var>animation
            duration</var> (see <a href="#calculating-the-animation-duration"
            class="sectionRef"></a>).
          </p>
          <p>
            Some examples are illustrated below.
          </p>
          <div class="figure">
            <object data="img/animation-interval-examples.svg"
              width="600"></object>
          </div>
          <p class="caption">
            Examples of the effect of the start delay on endpoints of the
            animation interval.<br>
            (a) An animation instance with no delay; the start time and start of
            animation are coincident.<br>
            (b) An animation instance with a positive delay; the start of
            animation is deferred by the delay.<br>
            (c) An animation instance with a negative delay; the start of
            animation is brought forward by the delay.
          </p>
        </section>
      </section>
      <section>
        <h3>Animation fill behavior</h3>
        <p class="todo">
          TBD.
        </p>
      </section>
      <section class="informative">
        <h3>Iteration time and animation time</h3>
        <p>
          Times in Web Animations are relative to some point of reference. These
          different points of reference produce different time spaces.
        </p>
        <p class="todo">
          Re-introduce coordinate space analogue? Drop "document time space" and
          "parent iteration time space" ?
        </p>
        <p>
          Within Web Animations, the following time spaces are used:
        </p>
        <dl>
          <dt>Document time space</dt>
          <dd>
            A time space whose zero point is the start time of the document
            timeline as defined in <a href="#start-of-the-timeline"
            class="sectionRef"></a>.
          </dd>
          <dt>Parent iteration time space</dt>
          <dd>
            A time space whose zero time is the beginning of the parent
            animation group's current iteration.
            Unless the document creates additional animation groups, this will
            be equivalent to document time.
          </dd>
          <dt>Item time space</dt>
          <dd>
            A time space whose zero time is when the item becomes active.
          </dd>
          <dt>Animation time space</dt>
          <dd>
            A time space whose zero time is when the item begins animating.
          </dd>
          <dt>Iteration time space</dt>
          <dd>
            A time space whose zero time is the beginning of the current
            iteration.
            When the animation instance is inactive it is set to the iteration
            time that will produce the appropriate fill value regardless of the
            setting of the fill mode.
          </dd>
        </dl>
        <p>
          Some of these time spaces are demonstrated below.
        </p>
        <div class="figure">
          <object data="img/time-spaces.svg" width="600"></object>
        </div>
        <p class="caption">
          A comparison of item time, animation time, and iteration time for an
          animation with a iteration duration of 1s and an iteration count of
          2.5.
        </p>
        <p class="todo">
          Need to explain that while the time space is unbounded, some times
          as-used-in-Web-Animations are clamped??? Either that or just remove
          the clamped parts from the diagram.
        </p>
        <section>
          <h4>Iteration duration and animation duration</h4>
          <p>
            These time spaces can also be used to describe intervals and
            durations. The distinction between iteration duration and active
            duration is particularly common. The definition of these terms falls
            out of the definition of the time spaces and is summarized as
            follows:
          </p>
          <dl>
            <dt>Iteration duration</dt>
            <dd>
              The time taken for a single iteration of the item to complete.
            </dd>
            <dt>Animation duration</dt>
            <dd>
              The time taken for the animation phase of the item to complete.
              This may be longer or shorter than the iteration duration.
            </dd>
          </dl>
          <p>
            This may be visualized as follows:
          </p>
          <div class="figure">
            <object data="img/iteration-and-animation-duration.svg"
                width="600"></object>
          </div>
          <p class="caption">
            A comparison of the iteration and animation durations for an
            animation with an iteration count of 2.5.<br>
            Note that the iteration duration for the final iteration does not
            change, it is simply cut-off by the animation duration.
          </p>
        </section>
        <section>
          <h4>Interval timing</h4>
          <p>
            For intervals of time, Web Animations uses an endpoint-exclusive
            timing model. This means that whilst the begin time of an interval
            is included in the interval, the end time time is not. In interval
            notation this can written <code>[begin,end)</code>. This model
            provides sensible behavior when intervals are repeated and sequenced
            since there is no overlap between intervals.
          </p>
          <p>
            In the examples below, for the repeated animation, at animation time
            1s, the iteration time is 0.
            For the sequenced animation, at parent iteration time 1s, animation
            A has become inactive, and animation B is now active; there is no
            overlap.
          </p>
          <div class="figure">
            <object data="img/endpoint-exclusive-timing.svg"
                width="600"></object>
          </div>
          <p class="caption">
            Illustration of end-point exclusive timing. For both repeated and
            sequenced animations there is no overlap at the boundaries between
            intervals.
          </p>
          <p>
            An exception to this behavior is that when performing a fill, if
            the fill begins at an interval endpoint, the endpoint is used. This
            behavior falls out of the algorithm given in <a
            href="#calculating-the-unscaled-iteration-time"
            class="sectionRef"></a> and is demonstrated below.
          </p>
          <div class="figure">
            <object data="img/endpoint-exclusive-timing-and-fill.svg"
                width="600"></object>
          </div>
          <p class="caption">
            After one iteration, the first frame of the animation is shown, but
            after two iterations (and thereonwards), the last frame is shown due
            to the special behavior defined when an animation fills.
          </p>
        </section>
      </section>
      <section>
        <h3>Calculating the iteration duration</h3>
        <p class="todo">
          The following algorithms are pretty intimidating apparently. Put them
          after the IDL? Or try to reduce the number of terms?
        </p>
        <p>
          The <var>iteration duration</var> is calculated according to the
          following steps:
        </p>
        <dl class="switch">
          <dt>
            If the <var>duration</var> timing property is set to a numerical
            value greater than or equal to zero (including positive infinity),
          </dt>
          <dd>
            return <var>duration</var>.
          </dd>
          <dt>
            Otherwise,
          </dt>
          <dd>
            return the item's <var>intrinsic duration</var>.
          </dd>
        </dl>
        <p>
          The value of an item's <var>intrinsic duration</var> depends on
          the type of the item. For animation instances the <var>intrinsic
          duration</var> is <code>Infinity</code>.
        </p>
        <p>
          The intrinsic duration for animation group instances and media items
          is described under <a
          href="#calculating-the-intrinsic-duration-of-an-animation-group-instance"
          class="sectionRef"></a> and <a
          href="#the-intrinsic-duration-of-a-media-item"
          class="sectionRef"></a> respectively.
        </p>
      </section>
      <section>
        <h3>Calculating the animation duration</h3>
        <p>
          The <var>animation duration</var> is calculated according to the
          following steps:
        </p>
        <ol>
          <li>
            Let the <var>repeated duration</var> be <code><var>iteration
            duration</var> * <var>iteration count</var></code>.
          </li>
          <li>
            If <var>speed</var> is zero, return <code>Infinity</code>.
          </li>
          <li>
            Otherwise, return <code><var>repeated duration</var>
            / abs(<var>speed</var>)</code>.
          </li>
        </ol>
      </section>
      <section>
        <h3>Calculating the item time</h3>
        <p>
          The <var>item time</var> is calculated according to the following
          equation:
        </p>
        <blockquote>
          <code><var>item time</var> = <var>parent time</var>
            - <var>start time</var> - <var>start offset</var></code>
        </blockquote>
        <p>where:</p>
        <ul>
          <li>
            <var>parent time</var> is the iteration time of the parent animation
            group instance.
          </li>
          <li>
            <var>start time</var> is the item's start time.
          </li>
          <li>
            <var>start offset</var> is the accumulated drift from the start
            time as described in <a href="#pausing-a-timed-item"
            class="sectionRef"></a>.
          </li>
        </ul>
        <p>
          If the timed item is not the child of a parent animation group
          instance, the <var>item time</var> is null.
        </p>
        <p class="todo">
          Need to define this for the document timeline.
        </p>
      </section>
      <section>
        <h3>Calculating the animation time</h3>
        <p>
          The <var>animation time</var> is calculated according to the following
          steps:
        </p>
        <ol>
          <li>
            If <var>item time</var> is <code>null</code>, return
            <code>null</code>.
          </li>
          <li>
            Let the <var>unrestricted animation time</var> be <code><var>item
            time</var> - <var>start delay</var></code>.
          </li>
          <li>
            If the <var>unrestricted animation time</var> is not in the range
            <code>[0, <var>animation duration</var>)</code>, return
            <code>null</code>.
          </li>
          <li>
            Otherwise, return the <var>unrestricted animation time</var>.
          </li>
        </ol>
      </section>
      <section>
        <h3>Calculating the iteration time</h3>
        <p>
          The iteration time is calculated by first dividing the <var>animation
          time</var> into intervals. This is called the <var>unscaled iteration
          time</var>. Following this, timing manipulations specified on the
          timed item are applied to the <var>unscaled iteration time</var> to
          produce the <var>iteration time</var>.
        </p>
        <section>
          <h4>Calculating the effective animation time</h4>
          <p>
            The <var>effective animation time</var> is calculated according to
            the following steps:
          </p>
          <ol>
            <li>
              If <var>item time</var> is <code>null</code>, return
              <code>null</code>.
            </li>
            <li>
              If <var>animation time</var> is not <code>null</code>, return
              <var>animation time</var>.
            </li>
            <li>
              If <code><var>item time</var> &gt;= <var>animation duration</var>
              + <var>start delay</var></code>, return <var>animation
              duration</var>.
            </li>
            <li>
              Otherwise, return zero.
            </li>
          </ol>
        </section>
        <section>
          <h4>Calculating the unscaled iteration time</h4>
          <p>
            The <var>unscaled iteration time</var> is calculated according to
            the following steps:
          </p>
          <ol>
            <li>
              If the <var>item time</var> is <code>null</code> (i.e. the
              animation's start time is not defined), return <code>null</code>.
            </li>
            <li>
              If the <var>iteration duration</var> is zero, return zero.
            </li>
            <li>
              If the <var>effective animation time</var> equals the
              <var>animation duration</var> and the <var>animation
              duration</var> is a positive (non-zero) multiple of <var>iteration
              duration</var>, return the <var>iteration duration</var>.
            </li>
            <li>
              Otherwise, return <code><var>effective animation time</var>
              % <var>iteration duration</var></code>.
            </li>
          </ol>
        </section>
        <section>
          <h4>Applying time manipulations</h4>
          <p>
            The <var>unscaled iteration time</var> is converted into the
            <var>iteration time</var> using the following steps:
          <ol>
            <li>
              If the <var>unscaled iteration time</var> is <code>null</code>,
              return <code>null</code>.
            </li>
            <li>
              Let <var>scaled iteration time</var> be the result of applying any
              timing function defined for this timed element to the
              <var>unscaled iteration time</var>. <span class="todo">(Need more
              detail here, or a link to where this is defined.)</span>
            </li>
            <li>
              Calculate the <var>current direction</var> using the first
              matching condition from the following list:
              <dl class="switch">
                <dt>
                  If the direction is normal,
                </dt>
                <dd>Let the <var>current direction</var> be forwards.</dd>
                <dt>
                  If the direction is reverse,
                </dt>
                <dd>Let the <var>current direction</var> be reverse.</dd>
                <dt>
                  Otherwise,
                </dt>
                <dd>
                  <ol>
                    <li>
                      Let <var>d</var> be the <var>current iteration</var> (see
                      <a href="#calculating-the-current-iteration"
                        class="sectionRef"></a>).
                    </li>
                    <li>
                      If the direction is alternate-reverse increment
                      <var>d</var> by 1.
                    </li>
                    <li>
                      If the animation is not animating, and the
                      <var>animation duration</var> is a positive multiple of
                      the <var>iteration duration</var> increment <var>d</var>
                      by 1.
                    </li>
                    <li>
                      If <code><var>d</var> % 2 != 0</code>, let the
                      <var>current direction</var> be forwards, otherwise let
                      the <var>current direction</var> be reverse.
                    </li>
                  </ol>
                </dd>
              </dl>
            </li>
            <li>
              If the <var>speed</var> timing property is negative, reverse the
              <var>current direction</var>.
            </li>
            <li>
              If the <var>current direction</var> is forwards then return
              the <var>scaled iteration time</var>.
              <p>
                Otherwise, return the <var>iteration duration</var>
                - <var>scaled iteration time</var>.
              </p>
            </li>
          </ol>
          <p class="note">
            Applying the reverse behavior after applying the timing function
            means that ease-in becomes ease-out on reverse, however it avoids
            jumps in values when reversing part-way.
          </p>
        </section>
        <section>
          <h4>Calculating the current iteration</h4>
          <p>
            The <var>current iteration</var> can be calculated from the
            following steps:
          </p>
          <ol>
            <li>
              If the <var>item time</var> is <code>null</code>, return
              <code>null</code>.
            </li>
            <li>
              If the <var>effective animation time</var> is zero, return zero.
            </li>
            <li>
              If the <var>iteration duration</var> is zero, return
              <code>floor(<var>iteration count</var>)</code>.
            </li>
            <li>
              Return <code>floor(<var>effective animation time</var> /
              <var>iteration duration</var>)</code>.
              <p class="note">
                If the <var>iteration duration</var> is infinite, the
                result of <code>floor(<var>effective animation time</var> /
                <var>iteration duration</var>)</code> will be zero as defined by
                IEEE 754.
              </p>
            </li>
          </ol>
        </section>
      </section>
      <section class="informative">
        <h3>Pausing a timed item</h3>
        <p>
          Timed items may be paused and resumed independently of the parent
          animation group instance they belong to.
          The effect is that the time of the item drifts from that of its
          parent.
          This drift is called the <var>start offset</var> since it acts as an
          additional delay added to the <var>start time</var> of the item.
        </p>
        <p>
          Timed elements that do not have a parent animation group may still be
          paused and resumed.
          However, except for the case of the document timeline, there will be
          no observable effect until the element is attached to a parent
          animation group instance.
        </p>
        <p>
          The <var>start offset</var> produced by pausing can be calculated as
          follows:
        </p>
        <ol>
          <li>
            Let <var>start offset</var> be initially zero.
          </li>
          <li>
            When the pause state is newly true, record the <var>parent iteration
            time</var> as <var>pause start time</var>.
          </li>
          <li>
            On the next sample, increment <var>start offset</var> by
            <code><var>parent iteration time</var> - <var>pause start
            time</var></code>.
          </li>
          <li>
            Update <var>pause start time</var> to <var>parent iteration
            time</var>.
          </li>
          <li>
            Repeat steps 3 and 4 for each sample while paused and when the pause
            state is newly false.
          </li>
        </ol>
        <p>
          An important characteristic of the above procedure is that the
          <var>start offset</var> continues to accumulate while the
          item is paused. As a result, the <var>start offset</var> must be
          calculated prior to calculating the <var>item time</var>.
        </p>
      </section>
      <section>
        <h3>Seeking a timed item</h3>
        <p>
          Seeking, like pausing, has the effect of causing a timed item's
          time to drift from that of its parent animation group instance.
        </p>
        <p>
          When a seek operation is performed, the <var>start offset</var> is set
          according to the following formula:
        </p>
        <blockquote>
          <code><var>start offset</var> = <var>parent iteration time</var>
            - <var>start time</var> - <var>seek time</var></code>
        </blockquote>
        <p>where:</p>
        <ul>
          <li>
            <var>parent iteration time</var> - is the iteration time of the
            parent animation group instance if there is one, otherwise it is
            zero.
          </li>
          <li>
            <var>start time</var> - is the start time of the item being
            seeked.
          </li>
          <li>
            <var>seek time</var> - is the time to seek to expressed in the
            item time space.
          </li>
        </ul>
        <p>
          The animation events dispatched when a seek is performed are described
          in <a href="#animation-events" class="sectionRef"></a>.
        </p>
        <p class="informative">
          Note that seeking a timed item does not reset the state of the timed
          item or its children.
          For example, if an application is configured to produce new animations
          in response to animation end events, seeking the document timeline
          backwards will not remove the created animations. As a result, a naive
          application may create overlapping animations on subsequent replays.
          It is the application's responsibility to restore the original state
          of the document in such situations.
        </p>
        <p class="feedbackWanted">
          Is it worth adding "seek" events for this? Or the ability to mark
          animations as "remove-on-seek" (or something of that ilk).
        </p>
        <p class="feedbackWanted">
          I wonder if it makes sense to clear accumulated start offsets in some
          states. If you rewind a document to the start, then it's perhaps
          counter-intuitive if, on replay, the accumulated start offset due to
          pauses still takes effect. Or maybe it's ok? Bear in mind, that if we
          do add some feature here, it should ideally work the same when the
          document is played in reverse.
        </p>
      </section>
      <section>
        <h3>Specifying timing properties</h3>
        <p>
          Timing properties are collected under the <code>WebTiming</code>
          interface.
          All properties have a default value associated with them with is the
          value used when a new <code>WebTiming</code> object is constructed.
        </p>
        <section>
          <h3>The <code>WebTiming</code> interface</h3>
          <dl title="interface WebTiming" class="idl">
            <dt>const unsigned short WEBA_FILL_NONE = 0</dt>
            <dd>
              No fill.
            </dd>
            <dt>const unsigned short WEBA_FILL_FORWARDS = 1</dt>
            <dd>
              Fill forwards (=<code>fill="freeze"</code> in SVG speak).
            </dd>
            <dt>const unsigned short WEBA_FILL_BACKWARDS = 2</dt>
            <dd>
              Fill backwards.
            </dd>
            <dt>const unsigned short WEBA_FILL_BOTH = 3</dt>
            <dd>
              Fill backwards and forwards.
            </dd>
            <dt>const unsigned short WEBA_DIRECTION_NORMAL = 0</dt>
            <dd>
              All iterations are played as specified.
            </dd>
            <dt>const unsigned short WEBA_DIRECTION_REVERSE = 1</dt>
            <dd>
              All iterations are played in the reverse direction from the way
              they were specified.
            </dd>
            <dt>const unsigned short WEBA_DIRECTION_ALTERNATE = 2</dt>
            <dd>
              Even iterations are played as specified, odd iterations are played
              in the reverse direction from the way they were specified.
            </dd>
            <dt>const unsigned short WEBA_DIRECTION_ALTERNATE_REVERSE = 3</dt>
            <dd>
              Even iterations are played in the reverse direction from the way
              they were specified, odd iterations are played as specified.
            </dd>
            <dt>attribute float startDelay</dt>
            <dd>
              <p>
                The number of seconds from the timed item's
                <code>startTime</code> until the timed item should begin
                executing.
              </p>
              <p>
                The <var>default value</var> is 0.
              </p>
            </dd>
            <dt>attribute unrestricted float? duration</dt>
            <dd>
              <p>
                The duration specified for a single iteration. This may be
                <code>null</code> in which case the intrinsic duration will be
                used. If set, it must be greater than or equal to zero
                (including positive infinity).
              </p>
              <p>
                The <var>default value</var> is <code>null</code>.
              </p>
            </dd>
            <dt>attribute unrestricted float iterationCount</dt>
            <dd>
              <p>
                A real number greater than or equal to zero (including positive
                infinity) representing the number of times to repeat the
                animation.
              </p>
              <p>
                The <var>default value</var> is 1.
              </p>
            </dd>
            <dt>attribute float speed</dt>
            <dd>
              <p>
                A real number that acts as a multiplier on the item's rate of
                play. For example, a value of 2.0 will cause the item to run at
                twice its usual speed. A value of -1.0 will cause the item to
                play backwards.
              </p>
              <p>
                Setting this attribute will affect the item's active duration as
                described in <a href="#calculating-the-animation-duration"
                class="sectionRef"></a>.
              </p>
              <p>
                The <var>default value</var> is 1.
              </p>
            </dd>
            <dt>attribute unsigned short direction</dt>
            <dd>
              <p>
                Direction behavior as specified by one of the
                <code>WEBA_DIRECTION_*</code> constants defined in this
                interface.
              </p>
              <p>
                The <var>default value</var> is
                <code>WEBA_DIRECTION_NORMAL</code>.
              </p>
            </dd>
            <dt>attribute WebTimingFunction timingFunction</dt>
            <dd class="todo">
              TBD.
            </dd>
            <dt>attribute unsigned short fill</dt>
            <dd>
              <p>
                Fill mode as specified by one of the <code>WEBA_FILL_*</code>
                constants defined in this interface.
              </p>
              <p>
                The <var>default value</var> is <code>WEBA_FILL_NONE</code>.
              </p>
            </dd>
          </dl>
        </section>
      </section>
      <section>
        <h3>The <code>WebTimedItem</code> interface</h3>
        <p>
          Represents the timing properties and methods of an animation actor:
          either a <a>WebAnimationInstance</a> or
          a <a>WebAnimationGroupInstance</a>.
        </p>
        <dl title="interface WebTimedItem" class="idl">
          <dt>readonly attribute WebTiming timing</dt>
          <dd>
            The timing parameters for this item.
          </dd>
          <dt>readonly attribute unrestricted float iterationDuration</dt>
          <dd>
            The iteration duration calculated for this item. If
            <code>timing.duration</code> is set and greater than or equal to
            zero, this will match <code>timing.duration</code>. Otherwise,
            this will reflect the calculated intrinsic duration of the item as
            described in <a href="#calculating-the-iteration-duration"
              class="sectionRef"></a>.
          </dd>
          <dt>readonly attribute float animationDuration</dt>
          <dd>
            The amount of time in seconds the animation is scheduled to animate
            as described in <a href="#calculating-the-animation-duration"
              class="sectionRef"></a>.
          </dd>
          <dt>readonly attribute unsigned long? currentIteration</dt>
          <dd>
            The number of iterations that have completed as described in <a
              href="#calculating-the-current-iteration" class="sectionRef"></a>.
          </dd>
          <dt>readonly attribute float startTime</dt>
          <dd>
            <p>
              The time at which the animation becomes active expressed in
              seconds relative to the parent animation group.
            </p>
            <p class="todo">
              As with <code>endTime</code> and the proposed <code>stop()</code>
              method below, add <code>start()</code> to set this here?
              Throws exception for children of a sequence container?
            </p>
          </dd>
          <dt>readonly attribute float endTime</dt>
          <dd>
            <p>
              The time at which the animation ceases to be active expressed in
              seconds relative to the parent animation group.
            </p>
            <p class="todo">
              I think we need a means to change this while leaving the animation
              in the tree, e.g. <code>stop(optional timeFromNow = 0)</code>.
              For most interactive animations though <code>cancel()</code>
              (which removes the item from the tree) should be suitable.
            </p>
          </dd>
          <dt>readonly attribute unrestricted float? iterationTime</dt>
          <dd>
            The time in seconds representing the offset into the iteration
            duration using the steps described in <a
              href="#calculating-the-iteration-time" class="sectionRef"></a>. As
            a result of that definition, this property will be
            non-<code>null</code> only when the animation is affecting its
            target.
          </dd>
          <dt>readonly attribute float? animationTime</dt>
          <dd>
            The time in seconds representing the offset into the animation
            phase. It is calculated using the steps described in <a
              href="#calculating-the-animation-time" class="sectionRef"></a>. As
            a result of that definition, this property will be
            non-<code>null</code> if and only if the animation is in the
            animating phase.
          </dd>
          <dt>readonly attribute WebAnimationGroupInstance parentGroup</dt>
          <dd>
            The parent animation group instance.
          </dd>
          <dt>readonly attribute float startOffset</dt>
          <dd>
            The number of seconds that the actual item time of this item
            lags behind the time given by <code><var>parent iteration time</var>
            - <var>start time</var></code> as a result of pausing and seeking
            this item.
          </dd>
          <dt>void setPauseState (bool pauseState)</dt>
          <dd>
            Sets the pause state of this timed item.
          </dd>
          <dt>bool getPauseState ()</dt>
          <dd>
            Returns the pause state of this timed item. Note that even if this
            returns false, the timed item might still be effectively paused by
            an ancestor animation group.
          </dd>
          <dt>bool isPaused ()</dt>
          <dd>
            Returns <code>true</code> if the pause state of this
            object <em>or one of its ancestor animation groups</em> is
            <code>true</code>.
          </dd>
          <dt>void seek (unsigned long itemTime)</dt>
          <dd>
            Performs a seek operation on this timed item according to the steps
            described in <a href="#seeking-a-timed-item"
            class="sectionRef"></a>.
            <code>itemTime</code> is a time in seconds in <em>item time</em>
            space (see <a href="#iteration-time-and-animation-time"
            class="sectionRef"></a>).
          </dd>
          <dt>void changeSpeed (float speed)</dt>
          <dd>
            Updates the <code>timing.speed</code> property to match the
            <code>speed</code> parameter and performs a compensatory seek such
            that the <var>animation time</var> does not change. <span
            class="todo">Need to write out the algorithm for this and clarify
            the meaning <code>speed</code>.</span>
          </dd>
          <dt>void cancel ()</dt>
          <dd>
            Removes the timed item from its parent group. As a result, the
            timed item will no longer affect its target.
          </dd>
        </dl>
        <div class="feedbackWanted">
          How about a <code>reverse</code> method? What it does is call
          <code>cancel</code> on the timed item.
          Then it generates a clone with the <code>startTime</code> set to the
          current time (actually, we probably want to use the delay so the
          reverse animation has the same priority).
          Then it sets the <code>direction</code> to its opposite (i.e.
          normal&#x2194;reverse, alternate&#x2194;alternate-reverse) and returns
          the new timed item? (Need to make sure we avoid object-slicing here.)
        </div>
        <div class="todo">
          <p>
            Do we need means for getting the startTime etc. in document
            time (i.e. in terms of the root time container)?
          </p>
        </div>
      </section>
    </section>

    <section>
      <h2>Controlling animation playback rate</h2>
      <p class="todo">
        TBD.
        Need to define timing functions and the ability to provide custom
        functions to scale a time.
        Not even sure what this section should be called or if it should be
        subsection of the previous section.
        &ldquo;Scaling the time&rdquo;?
      </p>
      <h3>The <code>WebTimingFunction</code> interface</h3>
      <p class="todo">
        TBD.
      </p>
      <dl title="interface WebTimingFunction" class="idl">
      </dl>
    </section>

    <section class="informative">
      <h2>Grouping and synchronization</h2>
      <p>
        While it is possible to set the timing properties of animations and
        their instances individually, it is often useful to bundle animations
        together and control their timing as a group.
      </p>
      <p>
        This can be used to share common timing properties as illustrated below:
      </p>
      <div class="figure">
        <object data="img/grouping-delay.svg" width="800"></object>
      </div>
      <p class="caption">
        Using groups to share common timing properties.<br>
        (a) Shows setting a delay of 5 seconds on individual animations.<br>
        (b) Produces the same effect by setting the delay on the group.
      </p>
      <p>
        As well as sharing timing information, by grouping animations together
        they can be seeked, paused, and stopped as a unit.
      </p>
      <section class="informative">
        <h3>Relationship of group time to child time</h3>
        <p>
          The timing of the children of a group is based on the timing of the
          group. Specifically, times for the children are based on the parent's
          <em>iteration time</em>. That is, the children animate <em>inside</em>
          an iteration of the parent.
        </p>
        <p>
          As an example, consider repetition. If a group has an iteration count
          of 3, then the children of of the group will all play three times
          since they effectively play <em>inside</em> the group's iterations.
        </p>
        <div class="figure">
          <object data="img/grouping-repetition.svg" width="600"></object>
        </div>
        <p class="caption">
          Since children of an animation group base their timing on the group's
          <var>iteration time</var>, when the group repeats, the children play
          again.
        </p>
        <p>
          If an iteration count is specified for the children of a group as well
          as for the group the effect is as if the iteration count of the group
          was multiplied with the iteration count of the children.
        </p>
        <div class="figure">
          <object data="img/grouping-repetition-and-animation-repetition.svg"
            width="600"></object>
        </div>
        <p class="caption">
          Specifying an iteration count of 2 on an animation group and an
          iteration count of 3 on one of its children results in that child
          playing 6 times.
        </p>
        <p>
          A further result of the children of a group basing their timing on the
          group's <var>iteration time</var> is that they cannot animate outside
          of the group's active interval. This is because the <var>iteration
          time</var> of a group will not change outside its active interval.
          This allows groups to clip the playback of their children.
        </p>
        <div class="figure">
          <object data="img/grouping-clipping.svg" width="600"></object>
        </div>
        <p class="caption">
          In the first instance, an animation has a negative delay and an
          infinite iteration count.<br>
          However, when a similar animation is placed inside a group with
          a specified duration it has the effect of clipping the animation's
          duration.
        </p>
        <p>
          Some further consequences of group children basing their timing on
          their parent group's <var>iteration time</var> are:
        </p>
        <ul>
          <li>
            Setting the speed of an animation group will speed up or slow down
            all children.
          </li>
          <li>
            Changing the playback direction of an animation group will change
            the direction of all children.
          </li>
          <li>
            Applying a timing function to an animation group will affect the
            playback rate of all children.
          </li>
        </p>
      </section>
      <section class="informative">
        <h3>Types of groups</h3>
        <p>
          Groups can be used to provide synchronization behavior for its
          children.
          For example, one type of group runs its children in parallel, whilst
          another type runs the children in sequence.
        </p>
        <p>
          Compare the two arrangements illustrated below:
        </p>
        <div class="figure">
          <object data="img/grouping-types.svg" width="600"></object>
        </div>
        <p class="caption">
          Two types of animation groups.<br>
          (a) is a parallel group where all the children run simultaneously.<br>
          (b) is a sequence group where the children run in turn.
        </p>
        <p>
          Groups can also contain other groups which allows for more
          sophisticated synchronization.
        </p>
        <div class="figure">
          <object data="img/grouping-nesting.svg" width="600"></object>
        </div>
        <p class="caption">
          A sequence animation group that contains a parallel animation group as
          a child.<br>
          The parallel group waits for the previous child of the sequence
          group to finish, and then the children of the parallel group play
          simultaneously.
          After they have finished the next child of the sequence group plays.
        </p>
        <p>
          Web Animations defines three types of animation groups.
        </p>
        <dl>
          <dt>Parallel groups</dt>
          <dd>
            TBD
          </dd>
          <dt>Sequence groups</dt>
          <dd>
            TBD
          </dd>
          <dt>Media groups</dt>
          <dd>
            TBD
          </dd>
        </dl>
      </section>
      <p>
        Integration with <code>&lt;video&gt;</code> etc.
      </p>
      <section>
        <h3>The document timeline</h3>
        <p>
          TBD.
          Describe how the document timeline is just an animation group instance
          with the following special properties:
        </p>
        <ul>
          <li>
            It cannot be appended as a child of another group. As a result the
            <code>parentGroup</code> property returns <code>null</code>.
          </li>
          <li>
            A lot of other properties are read-only like
            <code>iterationCount</code> etc.
          </li>
          <li>
            Its startTime represents real-world time??? Can we align with the
            timestamps used in DOM (e.g. for events) here?
          </li>
        </ul>
      </section>
      <section>
        <h3>Calculating the intrinsic duration of an animation group
            instance</h3>
        <p>
          TBD, but basically:
        </p>
        <dl class="switch">
          <dt>If the type is parallel,</dt>
          <dd>
            Calc the endTime for each child and take the max
          </dd>
          <dt>If the type is sequence</dt>
          <dd>
            Sum all the animation durations + start delays (including
            negatives)
          </dd>
          <dt>If the type is media group</dt>
          <dd>
            Same as parallel?
          </dd>
        </dl>
      </section>
      <section>
        <h3>Calculating the start time for children of a sequence group</h3>
        <p>TBD</p>
      </section>
      <section>
        <h3>The <code>WebAnimationGroupInstance</code> interface</h3>
        <p>
          Represents a list of timed items which may be animation instances or
          nested animation group instances. Order is significant only when
          <code>type</code> is <code>WEBA_SYNC_SEQ</code>.
        </p>
        <div class="feedbackWanted">
          <p>
            For adding and removing items this interface relies on passing in
            actual <a>WebTimedItem</a> objects. This is similar to the Element
            interface but differs from many SVG interfaces which use numeric
            indices instead.
          </p>
          <p>
            Using objects instead of indices is generally more useful since,
            even if you only know the index you can easily convert it to an
            object (e.g. <code>remove(group.getItem(2))</code>) but the reverse
            conversion is more difficult. However, there are performance costs
            associated with creating these objects in situations where indices
            are sufficient.
          </p>
          <p>
            With the interface defined below, it's really hard to (a) remove and
            re-add an item in the same place, (b) move an item forward one
            place. DOM doesn't have this problem because it has
            <code>nextSibling</code> and co. The SVG interfaces also don't have
            this problem because they use indexes but they <em>do</em> have
            the problem that working with a passed in object is very difficult
            (because you don't know its index). Maybe we need nextSibling? Or
            something to take an item and find its index?
          </p>
          <p>
            Also, the use of exceptions below is perhaps a little inconsistent.
            I've used exceptions for cases which are exceptional. For
            <code>item</code> I think it's reasonable to return null (like
            <code>NodeList</code>). Likewise, for <code>remove</code> I think
            it's useful to just return <code>null</code> rather than throwing
            an exception (e.g. if it has already been removed / not yet added).
            Maybe you really want to return null if it has no parent and throw
            an exception if it belongs to another group?
          </p>
        </div>
        <dl title="[Constructor] interface WebAnimationGroupInstance
                   : WebTimedItem"
          class="idl">
          <dt>const unsigned short WEBA_SYNC_PAR = 0</dt>
          <dd>
            Parallel synchronization.
          </dd>
          <dt>const unsigned short WEBA_SYNC_SEQ = 1</dt>
          <dd>
            Sequence synchronization.
          </dd>
          <dt>const unsigned short WEBA_SYNC_MEDIA = 2</dt>
          <dd>
            Media group synchronization.
          </dd>
          <dt>readonly attribute unsigned long length</dt>
          <dd>
            The number of timed items in the group.
          </dd>
          <dt>attribute unsigned short type</dt>
          <dd>
            <p>
              The type of synchronization provided by this animation group
              instance as specified by one of the <code>WEBA_SYNC_*</code>
              constants defined in this interface.
            </p>
            <p>
              Setting this value has the following effect:
            </p>
            <ol>
              <li>
                If <code>type</code> is set to the same value as the previous
                value return.
              </li>
              <li>
                Record the current container time.
              </li>
              <li>
                For each child in the group, call <code>cancel</code>.
              </li>
              <li>
                Seek the container time to zero.
              </li>
              <li>
                Calculate the effective start time of each child in the
                animation group instance using the new synchronization type.
                <span class="todo">(Need a cross-reference to somewhere where we
                describe this behavior and define things like "effective
                start time".)</span>
              </li>
              <li>
                Seek the container time to the previously recorded time.
              </li>
            </ol>
            <p class="feedbackWanted">
              Note that a consequence of the above is that, for example, if you
              change a container from type <code>par</code> to
              <code>mediaGroup</code> you could potentially generate a lot of
              end events followed by a lot of begin events despite the fact that
              the animation might not produce any different visual result. We
              could change the behavior so that it effectively records the
              play state of each item before and then after the "seek"
              dispatches the appropriate events.
            </p>
          </dd>
          <dt>void clear ()</dt>
          <dd>
            Removes all child timed items from the group.
          </dd>
          <dt>WebTimedItem append (WebTimedItem newItem)</dt>
          <dd>
            Add <code>newItem</code> as the last item in the group. If
            <code>newItem</code> already belongs to a group (including this
            group) it will first be removed from that group before being added
            to this group. Returns <code>newItem</code>.
          </dd>
          <dt>WebTimedItem insertBefore (WebTimedItem newItem,
            WebTimedItem? refItem)</dt>
          <dd>
            <p>
              Inserts <code>newItem</code> before the existing
              <code>refItem</code>. If <code>refItem</code> is null,
              <code>newChild</code> is added to the end of the list. If
              <code>newItem</code> already belongs to a group (including this
              group) it will first be removed from that group before being added
              to this group. If <code>newItem</code> and <code>refItem</code>
              are the same object then no change is made. Returns
              <code>newItem</code>.
            </p>
            <p class="feedbackWanted">
              What events are fired? If <code>newChild</code> is removed from
              a group then fire end event?
            </p>
            <p>Exceptions:</p>
            <ul>
              <li>HIERARCHY_REQUEST_ERR: Raised if <code>newItem</code> is
              a root animation group for a document <span class="todo">(need
              cross-ref here)</span>.</li>
              <li>NOT_FOUND_ERR: Raised if <code>refItem</code> is not a child
              of this group.</li>
            </ul>
          </dd>
          <dt>WebTimedItem? item (unsigned long index)</dt>
          <dd>
            Returns the item at <code>index</code>. If <code>index</code> is
            greater than or equal to <code>length</code> returns
            <code>null</code>. Equivalent to
            <code>WebAnimationGroup[index]</code>. <span class="todo">(Need to
            work out how to define this behavior&mdash;i.e. that you can use the
            subscript operator)</span>
          </dd>
          <dt>WebTimedItem? remove (WebTimedItem removedItem)</dt>
          <dd>
            Removes <code>removedItem</code> from the group and returns it. If
            <code>removedItem</code> is not part of this group, returns
            <code>null</code>.
          </dd>
          <dt>sequence&lt;WebAnimationInstance&gt; getActiveAnimations ()</dt>
          <dd>
            Returns all descendent <code>WebAnimationInstance</code> objects
            that are active.
            The returned sequence is a snapshot (i.e. not live) representing the
            state of animations that corresponds to the time returned by the
            <code>iterationTime</code> property of this
            <code>WebAnimationGroupInstance</code> object when this method was
            called.
          </dd>
          <dt>sequence&lt;WebAnimationInstance&gt; getAnimationsForElement
            (Element elem)</dt>
          <dd>
            Returns all descendent <code>WebAnimationInstance</code> objects
            whose <code>targetElement</code> is <code>elem</code>.
            As with <code>getActiveAnimations</code>, the returned sequence is
            a snapshot (i.e. not live) representing the state of animation
            when this method was called.
          </dd>
        </dl>
      </section>
    </section>

    <section>
      <h2>Animation values</h2>
      <section>
        <h3>The <code>WebAnimationFunction</code> interface</h3>
        <div class="todo">
          <p>
            This should probably become a superclass from which we create
            <code>WebKeyframesFunction</code> and
            <code>WebTwoValuedFunction</code>. It seems like it might even be
            useful to allow script to provide its own function. I'm not sure how
            that works exactly, but if we were to support that, then the
            interface would be something like:
          </p>
          <ul>
            <li>
              <code>Sample(float iterationProgress, Element target, any
              underlyingValue)</code> (where <code>iterationProgress</code> is
              the ratio of <var>iteration time</var> to <var>iteration
              duration</var>)
            </li>
          </ul>
          <p>
            Implementations of the function would be expected to produce the
            same result given the same parameters so the implementation could
            cache the result and not call the function when the parameters were
            the same.
          </p>
          <p>
            That would potentially let you animate anything. Anything! (And,
            that could be bad. The callback could rewrite the entire document
            every sample. After returning from the callback you'd have to do
            a lot of checks regarding the state of the world before continuing.)
          </p>
        </div>
        <p>
          I think most of the members of the interface, perhaps all, should be
          readonly when this object is returned from
          a <code>WebAnimationInstance</code> object. Objects returned from
          a <code>WebAnimation</code>, however, are live.
        </p>
        <p>
          <dl title="[Constructor] interface WebAnimationFunction" class="idl">
            <dt>const unsigned short WEBA_OPERATION_REPLACE = 0</dt>
            <dd>
              This animation should replace the value it is composited with.
            </dd>
            <dt>const unsigned short WEBA_OPERATION_ACCUMULATE = 1</dt>
            <dd>
              This animation should add to the value it is composited with.
              The meaning of addition is dependent on the type of animation.
            </dd>
            <dt>const unsigned short WEBA_OPERATION_MERGE = 2</dt>
            <dd>
              This animation should merge with the value it is composited with.
              The meaning of merge is dependent on the type of animation.
              The duration of the merge is the calculated animation duration of the <code>WebAnimation</code> containing this <code>WebAnimationFunction</code>.
            <dt>attribute DOMString property</dt>
            <dd>
              The target attribute / property. <code>property</code> is probably
              a reserved word we should avoid though.
            </dd>
            <dt>attribute WebAnimationFrameList frames</dt>
            <dd>
              The series of values that make up this function sorted by their
              offset within the iteration duration of the animation.
            </dd>
            <dt>attribute unsigned short operation</dt>
            <dd>
              The operation used to composite this animation with the stack, as specified by one of the <code>WEBA_OPERATION_*</code> constants defined in this interface.
            </dd>
            <dt>attribute unsigned short accumulateOperation</dt>
            <dd>
              The operation used to composite each iteration of this animation
              with the result of compositing the previous animation, as specified by one of the <code>WEBA_OPERATION_*</code> constants defined in this interface.
            </dd>
            <dt>attribute DOMString? pace</dt>
            <dd>
              This is just a placeholder for some kind of
              <i>whole-animation-function</i> timing control.
              For example, SVG has <code>calcMode="paced"</code> which looks at
              all the frames in the animation and adjusts the timing so the pace
              of change is constant (this is especially useful for motion on
              a path).<br>
              The example here could take values <code>null</code> (default),
              "auto", or something like "1px/s" (not sure what the datatype
              should be here).
              Not sure yet how this will work with adaptive duration if other
              animation functions use also this.
            </dd>
          </dl>
        </p>
      </section>
      <section>
        <h3>The <code>WebAnimationFrame</code> interface</h3>
        <p>
          <dl title="[Constructor] interface WebAnimationFrame" class="idl">
            <dt>attribute any value</dt>
            <dd>
              The attribute / property value for the given frame
            </dd>
            <dt>attribute float offset</dt>
            <dd>
              A value between 0 and 1 (inclusive) representing the offset within
              the iteration duration of the animation where this value should
              appear. Ignored if we're using paced timing?<br>
              What happens if you change it? The array returned by the
              <code>WebAnimationFunction</code> is updated? I guess that's fine
              if it's just an array. Any already-returned arrays wouldn't need
              to be updated.<br>
              What happens if you have two values with the same offset? It would
              be nice if the result was deterministic rather than just left up
              in the air (since the more you leave undefined, the more you let
              the Web define it for you).
            </dd>
            <dt>attribute WebTimingFunction timingFunction</dt>
            <dd>
              The function to use for this segment. Would a string do here? E.g.
              "ease" or "cubic-bezier(1 0 0.3 1)"? Probably not. It's a little
              too CSS-specific for a start, and we want to allow this to
              potentially be a function pointer.<br>
              Ignored if we're using paced timing
            </dd>
          </dl>
        </p>
      </section>
      <section>
        <h3>The <code>WebAnimationFrameList</code> interface</h3>
        <dl title="interface WebAnimationFrameList" class="idl">
          <dt>readonly attribute unsigned long length</dt>
          <dd>
            The number of frames in the list.
          </dd>
          <dt>WebAnimationFrameList? item(unsigned long index)</dt>
          <dd>
            Returns the frame at <code>index</code> if it exists or null.
          </dd>
          <dt>WebAnimationFrameList? add(WebAnimationFrame frame)</dt>
          <dd>
            Adds <code>frame</code> to the list such that the list is sorted
            by the offset of the frames. If there's already a frame with the
            same offset? This one comes after?
          </dd>
          <dt>WebAnimationFrameList? remove(unsigned long index)</dt>
          <dd>
            Adds <code>frame</code> to the list such that the list is sorted
            by the offset of the frames. If there's already a frame with the
            same offset? This one comes after?
          </dd>
        </dl>
        <p>
          Not sure about the <code>remove</code> method. Do we want:
          <ul>
            <li><code>remove(WebAnimationFrame frame)</code>?</li>
            <li><code>removeAtOffset(unsigned long offset)</code>?</li>
            <li><code>itemAtOffset(unsigned long offset)</code>?</li>
          </ul>
        </p>
      </section>
      <p>
        Need to add:
        <ul>
          <li>Pre-defined timing functions, spline-based timing functions etc.
          (want to allow a series of splines, not just four points)</li>
          <li>Custom easing functions</li>
          <li>Pace control (e.g. <code>pace="10px/s"</code>?)</li>
          <li>Motion on a path</li>
          <li>General functional syntax</li>
          <li>&lsquo;to&rsquo; animation</li>
        </ul>
      </p>
      <p>
        Somewhere we need to describe how animated values get stored in the DOM.
        i.e. can you access them at all? what's the interaction with various
        override stylesheets etc.
      </p>
      <p>
        Need to add a way for getting animation values of motion-on-a-path
        animations
      </p>
    </section>

    <section>
      <h2>Combining animations</h2>
      <section>
        <h3>The Animation Stack</h3>
        <p>
          When multiple active animations target the same element, the
          animations are ordered into a stack which resolves how those 
          animations combine. This stack is sorted by animation start time.
          Where multiple animations have the same start time, those animations
          are sorted in document order (for animations from the DOM) and script
          order (for animations from the API). Script animations are always
          sorted after DOM animations.
        </p>
        <p>
          The animation stack may be thought of as a single stack with all
          animations sorted into it, or a stack per animating element, as
          animations on one element cannot effect the course of animations on 
          another element.
        </p>
        <p class="note">
          The start time of an animation refers to the recorded or 
          calculated start time (i.e. the point where an animation changes 
          phase from <code>Inactive</code> to <code>Delayed</code>), not the
          point at which the animation actually starts (i.e. the point where
          an animation changes phase from <code>Delayed</code> to 
          <code>Animating</code>). 
        </p>
        <p class="note">
          The stacking order of animations is independent of the
          current play direction of individual animations and animation
          groups.
        </p>
      </section>
      <section>
        <h3>Resolving the Animation Stack</h3>
        <p>
          To calculate the current animation value for elements and properties
          from the animation stack, an animation value is generated for each
          animation in the stack.
          Starting at the bottom of the stack (i.e. earliest start time) and
          working up, the first encountered value relevant to each property of
          an element is adopted as the cumulative animation result for that
          element and property.
          As subsequent animation results are encountered for the same element
          and property, these are merged into the cumulative animation result
          using the animation combinator stored in the 
          <code>WebAnimationFunction</code>s that generate each subsequent
          result.
          Once all animation results in the stack are processed, the resulting
          cumulative animation values are the current animation values for
          each property of each element that is animated.
        </p>
        <p class="todo">
          Are we going to go down the path of base- and anim-val, like SVG
          does?
          Or direct manipulation of properties, like CSS?
        </p>
      </section>
      <section>
        <h3>Animation combinators</h3>
        <p>
          When an animation applies to a target and property that animations
          earlier in the animation stack have already applied to, the
          cumulative animation result from the stack is composited with the new
          animation to produce a new cumulative animation result.
          The possible combinators are defined as <code>WEBA_OPERATION_*</code>
          constants in the <code>WebAnimationFunction</code> interface.
        </p>
        <section>
          <h4>The REPLACE combinator</h4>
          <p>
            When an animation <code>a</code> is composited over a cumulative
            animation result <code>c</code> using the REPLACE combinator, the
            new cumulative animation result is always <code>a</code>.
          </p>
        </section>
        <section>
          <h4>The ACCUMULATE combinator</h4>
          <p>
            When a path animation <code>a</code> is composited over a
            cumulative animation result <code>c</code> using the ACCUMULATE
            combinator, the effective transform of <code>a</code> is calculated
            (see 
            <a href="#animations-in-the-timeline" class="sectionRef"></a>).
            This transform is then post-multiplied to the cumulative animation
            result to generate a new cumulative animation result.
          </p>
          <p>
            When a transform animation <code>a</code> is composited over a
            cumulative animation result <code>c</code> using the ACCUMULATE
            combinator, <code>a</code> is post-multiplied to the cumulative
            animation result to generate a new cumulative animation result.
          </p>
          <p>
            When a simple animation (i.e. an animation which is not a path
            animation nor a transform animation) <code>a</code> is composited
            over a cumulative animation result <code>c</code> using the
            ACCUMULATE combinator, the new cumulative animation result is the
            sum of <code>a</code> and <code>c</code>, clipped if necessary to
            the appropriate domain.
          </p>
        </section>
        <section>
          <h4>The MERGE combinator</h4>
          <p>
            All MERGE operators are governed by an interpolation parameter
            <code>p</code> that is calculated as the ratio of
            <code>(currentTime - parent.startTime) / parent.animationDuration</code>,
            where <code>parent</code> is the <code>WebAnimation</code> which
            references the <code>WebAnimationFunction</code> that is being
            composited.
          </p>
          <p>
            When a path animation <code>a</code> is composited over a
            cumulative animation result <code>c</code> using the MERGE
            combinator, the effective transform of <code>a</code> is
            calculated (see 
            <a href="#animations-in-the-timeline" class="sectionRef"></a>).
            This transform is then interpolated with <code>c</code> using the
            rules provided in ??? to provide the new cumulative animation
            result.
          </p>
          <p class="todo">
            Reference the CSS Transforms Module Level 3 here and below.
          </p>
          <p>
            When a transform animation <code>a</code> is composited over a
            cumulative animation result <code>c</code> using the MERGE
            combinator, <code>a</code> is interpolated with <code>c</code>
            using the rules provide in ??? to provide the new cumulative
            animation result.
          </p>
          <p>
            When a simple animation <code>a</code> is composited over a
            cumulative animation result <code>c</code> using the MERGE
            combinator, the new cumulative animation result is calculated as
            the weighted sum of <code>a</code> and <code>c</code>, with weights
            of <code>(1-p)</code> and <code>p</code> respectively.
          </p>
        </section>
      </section>
    </section>

    <section>
      <h2>Synchronizing with media</h2>
      <section>
        <h3>The intrinsic duration of a media item</h3>
        <p class="todo">
          Basically just take the <code>HTMLMediaElement.duration</code>
          property. Possibly convert <code>NaN</code> values to positive
          infinity.
        </p>
      </section>
      <section>
        <h3>The <code>WebMediaItem</code> interface</h3>
        <dl title="interface WebMediaItem : WebTimedItem" class="idl">
          <dt>attribute HTMLMediaElement element</dt>
          <dd>
            A pointer to the element?
          </dd>
        </dl>
      </section>
    </section>

    <section>
      <h2>Animation events</h2>
      <p>
        Need to consider how to align with existing
        <code>TransitionEvent</code>s, <code>AnimationEvent</code>s and
        <code>TimeEvent</code>s. It might make sense to have our events inherit
        from one or more of these interfaces or have implementations dispatch
        both (especially if their synchronization properties differ).
      </p>
      <p>
        I think we might also want a seek event? It seems like a lot of
        applications will want to do bookkeeping when there's
        a seek&mdash;especially a backwards seek. It might also be necessary for
        the SVG bindings so you can clear certain events on a backwards seek as
        required by SMIL.
      </p>
      <p>
        Talk about what events are dispatched on a seek.
      </p>
      <section>
        <h3>Synchronizing event handlers</h3>
        <p>
          Your text...
        </p>
      </section>
    </section>

    <section>
      <h2>Extensions to Document interfaces</h2>
      <p>
        Since the document acts as a root animation group user agents MUST add
        an <code>animationRoot</code> member to the document interface for each
        document type where animation is supported. For example, HTMLDocument
        and SVGDocument.
      </p>
      <p>
        The definition of this member is given below.
      </p>
      <dl title="partial interface HTMLDocument" class="idl">
        <dt>readonly attribute WebAnimationGroup animationRoot</dt>
        <dd>
          The animation group corresponding to the root of the document. This
          group exhibits the special behavior described for a root animation
          group in
          <a href="#grouping-and-synchronization" class="sectionRef"></a>.
        </dd>
      </dl>
    </section>

    <section>
      <h2>Animation of common data types</h2>
      <p>
        Need to describe how to interpolate/add both:
        <ol>
          <li>Integers, floats, strings etc.</li>
          <li>CSS and SVG types (colors etc.)</li>
          <ul><li>Support for HSL (if the colors are specified in HSL we should
            interpolate in that notation; but it should also be possible to
            do so regardless of how the colors are specified)</li></ul>
        </ol>
      </p>
      <p>
        For transforms I think it's defined elsewhere so we can either just
        point to that spec, or just refer to the fact that other specs should
        define how their types should be supported (or not) for animation.
      </p>
      <p>
        Need to provide facility for smooth interpolation of arbitrary paths.
      </p>
    </section>

    <section>
      <h2>Implementation requirements</h2>
      <section>
        <h3>Discarding past animations</h3>
        <p>
          If implementations are required to preserve all state associated with
          animations then the resources required by an animation could continue
          to increase without limit over time. For long-running animations, and
          particularly those where animations are added dynamically, this could
          lead to degraded performance and eventual failure.
        </p>
        <div class="issue">
          <p>
            I'm not sure how to define this. We could say all animations with
            <code><var>end time converted to document time</var> &lt;
            <var>current document time</var> - 5min</code> can be discarded.
          </p>
          <p>
            That's fine, but what about crazy documents that put 1 million
            animations in a 5min span? Just leave that up to the browser.
            Also, what about mobile clients, is 5 min too long? Is this too
            prescriptive?
          </p>
          <p>
            Maybe, just make some suggestions (e.g. 1 min for mobile clients,
            5 min for desktop?) and then define an exception to throw if there
            is a seek to some time outside that window.
          </p>
          <p>
            Also, note that defining this in terms of past intervals is
            direction-specific but that's probably ok since most long-running
            animations will run forwards.
          </p>
        </div>
      </section>
    </section>

    <section>
      <h2>Making animation accessible</h2>
      <p class="todo">
        TBD. Describe how to integrate with the <a
          href="http://www.whatwg.org/specs/web-apps/current-work/#timed-text-tracks">Timed
          Text API</a> and give examples of how to author content so it is
        accessible.
      </p>
    </section>
    <section class='appendix'>
      <h2>Acknowledgements</h2>
    </section>
  </body>
</html>
